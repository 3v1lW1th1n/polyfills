(function () {
'use strict';

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @type {Promise<void>} */
let readyPromise = null;

/** @type {?function(function())} */
let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
let resolveFn;

/**
 * @param {function()} callback
 */
function documentWait(callback) {
  if (whenReady) {
    whenReady(callback);
  } else {
    if (!readyPromise) {
      readyPromise = new Promise((resolve) => {resolveFn = resolve;});
      if (document.readyState === 'complete') {
        resolveFn();
      } else {
        document.addEventListener('readystatechange', () => {
          if (document.readyState === 'complete') {
            resolveFn();
          }
        });
      }
    }
    readyPromise.then(callback);
  }
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const PROCESSED_MARKER = '__processedByShadyCSS';
const SEEN_MARKER = '__seenByShadyCSS';

/** @type {?function(!HTMLStyleElement)} */
let transformFn = null;

/** @type {?function()} */
let validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/
class CustomStyleInterface {
  constructor() {
    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */
  enqueueDocumentValidation() {
    if (this['enqueued']) {
      return;
    }
    this['enqueued'] = true;
    documentWait(() => {
      validateFn();
    });
  }
  /**
   * @param {!HTMLStyleElement} style
   */
  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */
  getStyleForCustomStyle(customStyle) {
    let style;
    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }
    return style;
  }
  findStyles() {
    let cs = this['customStyles'];
    for (let i = 0; i < cs.length; i++) {
      let customStyle = cs[i];
      if (customStyle[PROCESSED_MARKER]) {
        continue;
      }
      let style = this.getStyleForCustomStyle(customStyle);
      if (style) {
        customStyle[PROCESSED_MARKER] = true;
        // HTMLImports polyfill may have cloned the style into the main document,
        // which is referenced with __appliedElement.
        // Also, we must copy over the attributes.
        let appliedStyle = /** @type {HTMLStyleElement} */(style['__appliedElement']);
        if (appliedStyle) {
          for (let i = 0; i < style.attributes.length; i++) {
            let attr = style.attributes[i];
            appliedStyle.setAttribute(attr.name, attr.value);
          }
        }
        if (transformFn) {
          transformFn(appliedStyle || style);
        }
      }
    }
  }
}

CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['findStyles'] = CustomStyleInterface.prototype.findStyles;

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get() {
      return transformFn;
    },
    /** @param {?function(!HTMLStyleElement)} fn */
    set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get() {
      return validateFn;
    },
    /** @param {?function()} fn */
    set(fn) {
      validateFn = fn;
    },
  }
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  return window.getComputedStyle(element).getPropertyValue(property).trim();
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const customStyleInterface = new CustomStyleInterface();

if (!window['ShadyCSS']) {
  window['ShadyCSS'] = {
    /**
     * @param {HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    ['prepareTemplate'](template, elementName, elementExtends) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    ['styleSubtree'](element, properties) {
      customStyleInterface.findStyles();
      updateNativeProperties(element, properties);
    },

    /**
     * @param {Element} element
     */
    ['styleElement'](element) { // eslint-disable-line no-unused-vars
      customStyleInterface.findStyles();
    },

    /**
     * @param {Object=} properties
     */
    ['styleDocument'](properties) {
      customStyleInterface.findStyles();
      updateNativeProperties(document.documentElement, properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    ['getComputedStyleValue'](element, property) {
      return getComputedStyleValue(element, property);
    },
    ['nativeCss']: true,
    ['nativeShadow']: true
  };
}

window['ShadyCSS']['CustomStyleInterface'] = customStyleInterface;

}());
//# sourceMappingURL=custom-style-interface.min.js.map
