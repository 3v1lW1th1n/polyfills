(function () {
'use strict';

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

var templateMap = {};

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
// chrome 49 has semi-working css vars, check if box-shadow works
// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
let nativeCssVariables = (!navigator.userAgent.match('AppleWebKit/601') &&
window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));

/**
 * @param {?Object} settings
 */
function parseSettings(settings) {
  if (settings) {
    nativeCssVariables = nativeCssVariables && !settings['shimcssproperties'];
    nativeShadow = nativeShadow && !settings['shimshadow'];
  }
}

if (window.ShadyCSS) {
  parseSettings(window['ShadyCSS']);
} else if (window.WebComponents) {
  parseSettings(window['WebComponents']['flags']);
}

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/

// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */


/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */


/**
 * @param {string} cssText
 * @return {string}
 */


/** @enum {number} */

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 */


/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */


// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */


/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */


// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */


/**
 * @param {Node} style
 * @param {?Node} target
 * @param {?Node} contextNode
 * @return {HTMLStyleElement}
 */


/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {Element}
 */


// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {Node}
 */


/**
 * @param {string} buildType
 * @return {boolean}
 */


/**
 * @param {Element} element
 * @return {?string}
 */


/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */


/**
 * @param {Element} element
 * @param {string} value
 */


/**
 * @param {Element|Object} element
 * @return {{is: string, extends: string}}
 */
function getIsExtends(element) {
  let is = element.is || (element.getAttribute && element.getAttribute('is')) || element.localName;
  let extendz = element.extends || element.localName !== is ? element.localName : '';
  return {is, extends: extendz};
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @const {Promise}
 */
const promise = Promise.resolve();

function invalidate(elementName){
  let template = templateMap[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

function invalidateTemplate(template) {
  template._applyShimInvalid = true;
}



function templateIsValid(template) {
  return !template._applyShimInvalid;
}



function templateIsValidating(template) {
  return template._validating;
}

/*
the template is marked as `validating` for one microtask so that all instances
found in the tree crawl of `applyStyle` will update themselves,
but the template will only be updated once.
*/


function startValidatingTemplate(template) {
  if (!template._validating) {
    template._validating = true;
    promise.then(function() {
      template._applyShimInvalid = false;
      template._validating = false;
    });
  }
}

class ApplyShimShim {
  constructor() {
    /** @type {Object} */
    this.impl;
  }
  ensure() {
    if (!this.impl) {
      this.impl = window['ApplyShim'] || {
        ['detectMixin'](){return false},
        ['transformRule'](){},
        ['transformRules'](){},
        ['transformTemplate'](){},
        ['transformCustomStyle'](){},
        ['transformStyle'](){}
      };
      this.impl['invalidCallback'] = invalidate;
    }
  }
  /**
   * @param {string} text
   * @return {boolean}
   */
  detectMixin(text) {
    this.ensure();
    return this.impl['detectMixin'](text);
  }
  /**
   * @param {StyleNode} ast
   * @param {string=} elementName
   */
  transformRules(ast, elementName) {
    this.ensure();
    return this.impl['transformRules'](ast, elementName);
  }
  /**
   * @param {StyleNode} ast
   */
  transformRule(ast) {
    this.ensure();
    this.impl['transformRule'](ast);
  }
  /**
   * @param {!HTMLStyleElement} style
   * @param {string=} elementName
   */
  transformStyle(style, elementName = '') {
    this.ensure();
    this.impl['transformStyle'](style, elementName);
  }
  /**
   * @param {!HTMLStyleElement} style
   */
  transformCustomStyle(style) {
    this.ensure();
    this.impl['transformCustomStyle'](style);
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */
  transformTemplate(template, elementName) {
    this.ensure();
    this.impl['transformTemplate'](template, elementName);
  }
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let ScopingShim;
let ApplyShim;
let CustomStyleInterface;

/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/** @implements {StylingInterface} */
class ShadyInterface {
  prepareTemplate(template, elementName, elementExtends) {
    ScopingShim['prepareTemplate'](template, elementName, elementExtends);
  }
  flushCustomStyles() {
    ScopingShim['flushCustomStyles']();
  }
  styleSubtree(element, properties) {
    ScopingShim['applySubtreeStyle'](element, properties);
  }
  styleElement(element) {
    ScopingShim['applyElementStyle'](element);
  }
  styleDocument(properties) {
    ScopingShim['updateStyles'](properties);
  }
}

/** @implements {StylingInterface} */
class ApplyInterface {
  constructor() {
    this.applyShim = new ApplyShimShim();
    this.customStyleInterface = null;
    this.booted = false;
  }
  ensure() {
    if (this.booted) {
      return;
    }
    this.customStyleInterface = window['CustomStyleInterface'];
    if (this.customStyleInterface) {
      this.customStyleInterface['transformCallback'] = (style) => {
        this.applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface['validateCallback'] = () => {
        this.flushCustomStyles();
      };
    }
    this.booted = true;
  }
  prepareTemplate(template, elementName) {
    this.ensure();
    templateMap[elementName] = template;
    this.applyShim.transformTemplate(template, elementName);
  }
  flushCustomStyles() {
    this.ensure();
    if (this.customStyleInterface) {
      this.customStyleInterface['findStyles']();
      let styles = this.customStyleInterface['customStyles'];
      for (let i = 0; i < styles.length; i++ ) {
        let cs = styles[i];
        let style = this.customStyleInterface['getStyleForCustomStyle'](cs);
        if (style) {
          this.applyShim.transformCustomStyle(style);
        }
      }
      this.customStyleInterface['enqueued'] = false;
    }
  }
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      updateNativeProperties(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree(shadowChildren[i]);
      }
    }
    let children = element.children || element.childNodes;
    for (let i = 0; i < children.length; i++) {
      this.styleSubtree(children[i]);
    }
  }
  styleElement(element) {
    this.ensure();
    let {is} = getIsExtends(element);
    let template = templateMap[is];
    if (template && !templateIsValid(template)) {
      // only revalidate template once
      if (!templateIsValidating(template)) {
        this.prepareTemplate(template, is);
        startValidatingTemplate(template);
      }
      // update all instances
      let root = element.shadowRoot;
      if (root) {
        let style = /** @type {HTMLStyleElement} */(root.querySelector('style'));
        if (style) {
          this.applyShim.transformStyle(style, is);
        }
      }
    }
  }
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.documentElement, properties);
  }
}

/** @implements {StylingInterface} */
class CustomOnlyInterface {
  constructor() {
    CustomStyleInterface['validateCallback'] = this.flushCustomStyles;
  }
  prepareTemplate() {}
  flushCustomStyles() {
    CustomStyleInterface['findStyles']();
    CustomStyleInterface['enqueued'] = false;
  }
  styleSubtree(element, properties) {
    updateNativeProperties(element, properties);
  }
  styleElement(element) {} // eslint-disable-line no-unused-vars
  styleDocument(properties) {
    updateNativeProperties(document.documentElement, properties);
  }
}

class ElementStyleInterface {
  constructor() {
    /** @type {StylingInterface} */
    this.styleInterface = null;
  }
  ensure() {
    if (this.styleInterface) {
      return;
    }
    ScopingShim = window['ScopingShim'];
    ApplyShim = window['ApplyShim'];
    CustomStyleInterface = window['CustomStyleInterface'];
    if (ScopingShim) {
      this.styleInterface = new ShadyInterface();
    } else if (ApplyShim) {
      this.styleInterface = new ApplyInterface();
    } else if (CustomStyleInterface) {
      this.styleInterface = new CustomOnlyInterface();
    }
  }
  /**
   * @param {HTMLTemplateElement} template
   * @param {string} elementName
   * @param {string=} elementExtends
   */
  prepareTemplate(template, elementName, elementExtends) {
    this.ensure();
    if (this.styleInterface) {
      this.styleInterface.prepareTemplate(template, elementName, elementExtends);
    }
  }

  /**
   * @param {Element} element
   * @param {Object=} properties
   */
  styleSubtree(element, properties) {
    this.ensure();
    if (this.styleInterface) {
      this.styleInterface.flushCustomStyles();
      this.styleInterface.styleSubtree(element, properties);
    }
  }

  /**
   * @param {Element} element
   */
  styleElement(element) {
    this.ensure();
    if (this.styleInterface) {
      this.styleInterface.flushCustomStyles();
      this.styleInterface.styleElement(element);
    }
  }

  /**
   * @param {Object=} properties
   */
  styleDocument(properties) {
    this.ensure();
    if (this.styleInterface) {
      this.styleInterface.flushCustomStyles();
      this.styleInterface.styleDocument(properties);
    }
  }

  /**
   * @param {Element} element
   * @param {string} property
   * @return {string}
   */
  getComputedStyleValue(element, property) {
    if (ScopingShim) {
      return ScopingShim['getComputedStyleValue'](element, property);
    } else {
      return window.getComputedStyle(element).getPropertyValue(property).trim();
    }
  }
}

ElementStyleInterface.prototype['prepareTemplate'] = ElementStyleInterface.prototype.prepareTemplate;
ElementStyleInterface.prototype['styleSubtree'] = ElementStyleInterface.prototype.styleSubtree;
ElementStyleInterface.prototype['styleElement'] = ElementStyleInterface.prototype.styleElement;
ElementStyleInterface.prototype['styleDocument'] = ElementStyleInterface.prototype.styleDocument;
ElementStyleInterface.prototype['getComputedStyleValue'] = ElementStyleInterface.prototype.getComputedStyleValue;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window['ElementStyleInterface'] = new ElementStyleInterface();

}());
//# sourceMappingURL=element-style-interface.min.js.map
