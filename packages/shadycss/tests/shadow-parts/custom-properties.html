<!doctype html>
<head>
  <script>
  WCT = {waitFor: function (cb) {HTMLImports.whenReady(cb)}}
  </script>
  <script src="../test-flags.js"></script>
  <script src="../../node_modules/wct-browser-legacy/browser.js"></script>
  <script src="../../node_modules/@webcomponents/webcomponents-platform/webcomponents-platform.js"></script>
  <script src="../../node_modules/es6-promise/dist/es6-promise.auto.min.js"></script>
  <script src="../../node_modules/@webcomponents/template/template.js"></script>
  <script src="../../node_modules/@webcomponents/html-imports/html-imports.min.js"></script>
  <script src="../../node_modules/@webcomponents/shadydom/shadydom.min.js"></script>
  <script src="../../node_modules/@webcomponents/custom-elements/custom-elements.min.js"></script>
  <script src="../../scoping-shim.min.js"></script>
  <script src="../../custom-style-interface.min.js"></script>
  <script src="../module/generated/make-element.js"></script>
  <script src="./utils.js"></script>
</head>
<body>

<template id="x-a1">
  <style>
    x-b {
      --custom-color: red;
      --custom-text-decoration: underline;
    }
    x-b.alt {
      --custom-color: black;
    }
  </style>
  <x-b></x-b>
  <x-b class="alt"></x-b>
</template>

<template id="x-a2">
  <style>
    x-b {
      --custom-color: green;
      --custom-text-decoration: line-through;
    }
  </style>
  <x-b></x-b>
</template>

<template id="x-b">
  <style>
    :host {
      color: var(--custom-color);
    }
    x-c::part(p1) {
      color: var(--custom-color);

      --custom-background-color: blue;
      background-color: var(--custom-background-color);

      font-style: var(--custom-font-style);
    }
    /** Note we have two part rules here to check that we handle multiple. */
    x-c::part(p1) {
      text-decoration: var(--custom-text-decoration);
    }
  </style>
  <x-c exportparts="p1"></x-c>
</template>

<template id="x-c">
  <style>
    :host {
      --custom-font-style: italic;
    }
  </style>
  <div part="p1">italic red or green on blue</div>
</template>

<x-a1></x-a1>
<x-a2></x-a2>

<script>
  suite('CSS Custom Properties', function() {
    let a1part, a2part;
    suiteSetup(async function() {
      makeElement('x-a1');
      makeElement('x-a2');
      makeElement('x-b');
      makeElement('x-c');
      await new Promise(r => requestAnimationFrame(r));
      a1part = pierce('x-a1', 'x-b', 'x-c', '[part=p1]');
      a2part = pierce('x-a2', 'x-b', 'x-c', '[part=p1]');
    });

    test('property set above rule', function() {
      assert.equal(getComputedStyle(a1part).color, red);
      assert.equal(getComputedStyle(a2part).color, green);
      assert.include(getComputedStyle(a1part).textDecoration, 'underline');
      assert.include(getComputedStyle(a2part).textDecoration, 'line-through');
    });

    test.skip('property set in part rule', function() {
      // TODO(aomarks) This still doesn't work because when we evaluate the
      // property values and create the style, we aren't taking into account
      // properties being set in the part rule itself. We could add special
      // handling for this. What would the right priority be vs other rules?
      assert.equal(getComputedStyle(a1part).backgroundColor, blue);
      assert.equal(getComputedStyle(a2part).backgroundColor, blue);
    });

    test('property set below rule', function() {
      assert.equal(getComputedStyle(a1part).fontStyle, 'italic');
      assert.equal(getComputedStyle(a2part).fontStyle, 'italic');
    });

    test('dynamic class', async function() {
      const a1 = pierce('x-a1');
      const b = pierce(a1, 'x-b.alt');
      const part = pierce(b, 'x-c', '[part=p1]');
      assert.equal(getComputedStyle(part).color, black);
      b.classList.remove('alt');
      ShadyCSS.styleSubtree(b);
      await new Promise(r => requestAnimationFrame(r));
      assert.equal(getComputedStyle(part).color, red);
    });
  });
</script>
</body>
