{"version":3,"sources":["src/common-regex.js"," [synthetic:util/global] ","src/style-settings.js","src/css-parse.js","src/style-util.js","src/apply-shim.js","src/style-transformer.js","src/document-watcher.js","src/template-map.js","src/style-info.js","src/style-properties.js","src/style-placeholder.js","src/shadycss.js","src/style-cache.js"],"names":["$jscomp.global","VAR_ASSIGN","MIXIN_MATCH","VAR_CONSUMED","ANIMATION_MATCH","MEDIA_MATCH","BRACKETED","nativeShadow","window","nativeCssVariables","navigator","userAgent","match","CSS","supports","parseSettings$$module$$src$style_settings","parseSettings","settings","ShadyCSS","WebComponents","module$$src$style_settings.nativeShadow","module$$src$style_settings.nativeCssVariables","parse$$module$$src$css_parse","parse","text","replace","RX$$module$$src$css_parse.comments","RX$$module$$src$css_parse.port","parseCss","root","start","end","length","n","i","l","OPEN_BRACE","rules","p","parent","previous","push","CLOSE_BRACE","parseCss$$module$$src$css_parse","node","t","substring","parsedCssText","cssText","trim","ss","_expandUnicodeEscapes","RX$$module$$src$css_parse.multipleSpaces","lastIndexOf","s","parsedSelector","selector","atRule","indexOf","AT_START","MEDIA_START","type","types$$module$$src$css_parse.MEDIA_RULE","RX$$module$$src$css_parse.keyframesRule","types$$module$$src$css_parse.KEYFRAMES_RULE","keyframesName","split","pop","VAR_START","types$$module$$src$css_parse.MIXIN_RULE","types$$module$$src$css_parse.STYLE_RULE","r$","r","_expandUnicodeEscapes$$module$$src$css_parse","code","repeat","stringify$$module$$src$css_parse","stringify","preserveProperties","RX$$module$$src$css_parse.customProp","RX$$module$$src$css_parse.mixinProp","RX$$module$$src$css_parse.mixinApply","RX$$module$$src$css_parse.varApply","STYLE_RULE","KEYFRAMES_RULE","MEDIA_RULE","MIXIN_RULE","comments","port","customProp","mixinProp","mixinApply","varApply","keyframesRule","multipleSpaces","toCssText$$module$$src$style_util","toCssText","callback","forEachRule","rulesForStyle$$module$$src$style_util","rulesForStyle","style","textContent","forEachRule$$module$$src$style_util","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","matchMedia","matches","applyCss$$module$$src$style_util","applyCss","moniker","target","contextNode","document","createElement","setAttribute","applyStyle","applyStyle$$module$$src$style_util","head","after","nextSibling","firstChild","lastHeadApplyNode","insertBefore","processVariableAndFallback$$module$$src$style_util","processVariableAndFallback","str","level","inner","prefix","suffix","comma","value","fallback","setElementClassRaw$$module$$src$style_util","setElementClassRaw","element","call","APPLY_NAME_CLEAN$$module$$src$apply_shim","INITIAL_INHERIT$$module$$src$apply_shim","constructor","MixinMap$$module$$src$apply_shim","_map","set","name","props","properties","dependants","get","invalidCallback$$module$$src$apply_shim","ApplyShim$$module$$src$apply_shim","_measureElement","_currentElement","ApplyShim$$module$$src$apply_shim$$module$$src$apply_shim.prototype","?.prototype","detectMixin","has","test","lastIndex","ApplyShim$$module$$src$apply_shim$$module$$src$apply_shim_prototype$transformStyle","transformStyle","elementName","ast","transformRules","transformRule","rule","transformCssText","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","_consumeCssProperties","m","exec","mixinName","idx","index","textBeforeApply","slice","textAfterApply","defaults","_cssTextToMap","f","parts","_atApplyToCssProperties","vars","mixinEntry","fallbacks","MIXIN_VAR_SEP$$module$$src$apply_shim","join","replacement","property","out","sp","_replaceInitialOrInherit","all","appendChild","getComputedStyle","getPropertyValue","_invalidateMixinEntry","mixinAsProperties","combinedProps","mixinValues","oldProps","Object","assign","create","v","needToInvalidate","undefined","prototype","defineProperty","cb","StyleTransformer","dom","scope","shouldRemoveScope","$jscompDefaultExport","_transformDom","nodeType","Node","ELEMENT_NODE","classList","remove","SCOPE_NAME","add","getAttribute","c","CLASS","newValue","c$","localName","childNodes","content","_content","children","elementStyles","styleRules","cssBuildType","__cssBuild","css","is","extends","ext","hostScope","_calcHostScope","CSS_CLASS_PREFIX","isScoped","transformedSelector","_transformRuleCss","self","_transformComplexSelector","transformer","p$","COMPLEX_SELECTOR_SEP","stop","NTH","SLOTTED_START","HOST","SIMPLE_SELECTOR_SEP","info","_transformCompoundSelector","combinator","slottedIndex","SLOTTED","_transformHostSelector","_transformSimpleSelector","slotted","SLOTTED_PAREN","paren","DIR_PAREN","before","dir","PSEUDO_PREFIX","HOST_PAREN","SIMPLE_SELECTOR_PREFIX","host","typeSelector","SELECTOR_NO_MATCH","_transformDocumentSelector","SCOPE_DOC_SELECTOR","$jscomp.global.Object.defineProperties","RegExp","flush$$module$$src$document_watcher","handler","mxns","x","mxn","documentElement","addedNodes","contains","hasAttribute","getRootNode","DOCUMENT_FRAGMENT_NODE","removedNodes","classes","Array","from","classIdx","observer","MutationObserver","observe","childList","subtree","customElements","delayedStart","body","requestAnimationFrame","readyState","listener","removeEventListener","addEventListener","flush","takeRecords","module$$src$document_watcher.flush","promise","Promise","resolve","StyleInfo","placeholder","ownStylePropertyNames","customStyle","scopeSelector","styleProperties","overrideStyleProperties","styleInfo","startValidating","template","_validating","then","_applyShimInvalid","Element","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","IS_IE","StyleProperties","decorateStyles","keyframes","ruleIndex","decorateRule","propertyInfo","onKeyframesRule","_keyframes","names","collectProperties","hasProperties","any","valueForProperty","valueForProperties","fn","propertyValue","colon","pp","propertyDataFromStyles","o","selectorToMatch","parseInt","key","whenHostOrRootRule","cssBuild","isRoot","isHost","hostAndRootPropertiesForScope","hostProps","rootProps","_element","transformStyles","hostSelector","hostRx","HOST_PREFIX","rxHostSelector","HOST_SUFFIX","StyleInfo$$module$$src$style_info.get","keyframeTransforms","_elementKeyframeTransforms","output","input","hasAnimations","keyframeNamesToTransform","keyframe","transform","keyframesRules","keyframesNameRx","transformedKeyframesName","scopeId","_keyframesRuleTransformer","applyCustomStyle","XSCOPE_NAME","placeholderMap","ce","origDefine","clazz","options","placeHolder","createComment","ApplyShim","invalidate","styleCache","cache","typeMax","_scopeCounter","_documentOwner","_documentOwnerStyleInfo","StyleInfo$$module$$src$style_info.set","ShadyCSS$$module$$src$shadycss.prototype","ShadyCSS$$module$$src$shadycss_prototype$flush","getStyleAst","styleAstToString","prepareTemplate","typeExtension","_prepared","querySelector","styles","querySelectorAll","parentNode","removeChild","hasMixins","_styleAst","_cssBuild","ownPropertyNames","shadowroot","_style","_ownPropertyNames","overrideProps","hasApplied","_isRootOwner","CS","customStyles","_updateProperties","_applyCustomStyles","updateStyles","removeProperty","setProperty","StyleInfo$$module$$src$style_info.startValidating","shadowRoot","list","entry","pn","cachedStyle","cacheEntry","styleElement","oldScopeSelector","cachedScopeSelector","id","shift","_applyToDescendants","_styleOwnerForNode","owner","ownerStyleInfo","hostAndRootProps","propertiesMatchingHost","propertyData","overrides","getOwnPropertyNames","_transformCustomStyleForDocument","ROOT","_transformRule","getComputedStyleValue","setElementClass","classString","scopeName","classAttr","k$","_styleInfoForNode","defineProperties"],"mappings":"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","file":"shadycss.min.js","sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nexport const VAR_ASSIGN = /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi;\nexport const MIXIN_MATCH = /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi;\nexport const VAR_CONSUMED = /(--[\\w-]+)\\s*([:,;)]|$)/gi;\nexport const ANIMATION_MATCH = /(animation\\s*:)|(animation-name\\s*:)/;\nexport const MEDIA_MATCH = /@media[^(]*(\\([^)]*\\))/;\nexport const IS_VAR = /^--/;\nexport const BRACKETED = /\\{[^}]*\\}/g;\nexport const HOST_PREFIX = '(?:^|[^.#[:])';\nexport const HOST_SUFFIX = '($|[.:[\\\\s>+~])';",null,"/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nexport let nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);\n// chrome 49 has semi-working css vars, check if box-shadow works\n// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\nexport let nativeCssVariables = (!navigator.userAgent.match('AppleWebKit/601') &&\nwindow.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));\n\n/**\n * @param {?Object} settings\n */\nfunction parseSettings(settings) {\n  if (settings) {\n    nativeCssVariables = nativeCssVariables && !settings['shimcssproperties'];\n    nativeShadow = nativeShadow && !settings['shimshadow'];\n  }\n}\n\nif (window.ShadyCSS) {\n  parseSettings(window['ShadyCSS']);\n} else if (window.WebComponents) {\n  parseSettings(window['WebComponents']['flags']);\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\n/** @record */\nexport let StyleNode = function(){};\n/** @type {number} */\nStyleNode.prototype.start;\n/** @type {number} */\nStyleNode.prototype.end;\n/** @type {StyleNode|undefined} */\nStyleNode.prototype.previous\n/** @type {Array<StyleNode>|undefined} */\nStyleNode.prototype.rules;\n/** @type {string|undefined} */\nStyleNode.prototype.parsedCssText;\n/** @type {string|undefined} */\nStyleNode.prototype.cssText;\n/** @type {boolean|undefined} */\nStyleNode.prototype.atRule;\n/** @type {number|undefined} */\nStyleNode.prototype.type;\n/** @type {string|undefined} */\nStyleNode.prototype.keyframesName;\n/** @type {string|undefined} */\nStyleNode.prototype.selector;\n/** @type {string|undefined} */\nStyleNode.prototype.parsedSelector;\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction lex(text) {\n  let root = {\n    start: 0,\n    end: text.length\n  };\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n.rules) {\n        n.rules = [];\n      }\n      let p = n;\n      let previous = p.rules[p.rules.length - 1];\n      n = {\n        start: i + 1,\n        parent: p,\n        previous: previous\n      };\n      p.rules.push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n.end = i + 1;\n      n = n.parent || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node.start, node.end - 1);\n  node.parsedCssText = node.cssText = t.trim();\n  if (node.parent) {\n    let ss = node.previous ? node.previous.end : node.parent.start;\n    t = text.substring(ss, node.start - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = node.parsedSelector = node.selector = t.trim();\n    node.atRule = (s.indexOf(AT_START) === 0);\n    // note, support a subset of rule types...\n    if (node.atRule) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node.type = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node.type = types.KEYFRAMES_RULE;\n        node.keyframesName =\n          node.selector.split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node.type = types.MIXIN_RULE;\n      } else {\n        node.type = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node.rules;\n  if (r$) {\n    for (let i = 0, l = r$.length, r;\n      (i < l) && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n// expanded form that doesn't require trailing space `\\000033`\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function() {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties, text) {\n  text = text || '';\n  // calc rule cssText\n  let cssText = '';\n  if (node.cssText || node.rules) {\n    let r$ = node.rules;\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r;\n        (i < l) && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties ? node.cssText :\n        removeCustomProps(node.cssText);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node.selector) {\n      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node.selector) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return Boolean(r) && Boolean(r.selector) && r.selector.indexOf(VAR_START) === 0;\n}\n\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\nexport function removeCustomPropAssignment(cssText) {\n  return cssText\n    .replace(RX.customProp, '')\n    .replace(RX.mixinProp, '');\n}\n\nfunction removeCustomPropApply(cssText) {\n  return cssText\n    .replace(RX.mixinApply, '')\n    .replace(RX.varApply, '');\n}\n\nexport let types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000\n}\n\nlet OPEN_BRACE = '{';\nlet CLOSE_BRACE = '}';\n\n// helper regexp's\nlet RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g\n}\n\nlet VAR_START = '--';\nlet MEDIA_START = '@media';\nlet AT_START = '@';\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {nativeShadow, nativeCssVariables} from './style-settings'\nimport {parse, stringify, types, StyleNode} from './css-parse'\nimport {MEDIA_MATCH} from './common-regex';\n\n/**\n * @param {string|StyleNode} rules\n * @param {function(!Array<Object>)=} callback\n */\nexport function toCssText (rules, callback) {\n  if (typeof rules === 'string') {\n    rules = parse(rules);\n  }\n  if (callback) {\n    forEachRule(rules, callback);\n  }\n  return stringify(rules, nativeCssVariables);\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @return {StyleNode}\n */\nexport function rulesForStyle(style) {\n  if (!style['__cssRules'] && style.textContent) {\n    style['__cssRules'] = parse(style.textContent);\n  }\n  return style['__cssRules'];\n}\n\n// Tests if a rule is a keyframes selector, which looks almost exactly\n// like a normal selector but is not (it has nothing to do with scoping\n// for example).\n/**\n * @param {StyleNode} rule\n * @return {boolean}\n */\nexport function isKeyframesSelector(rule) {\n  return rule.parent &&\n  rule.parent.type === types.KEYFRAMES_RULE;\n}\n\n/**\n * @param {StyleNode} node\n * @param {Function=} styleRuleCallback\n * @param {Function=} keyframesRuleCallback\n * @param {boolean=} onlyActiveRules\n */\nexport function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n  if (!node) {\n    return;\n  }\n  let skipRules = false;\n  if (onlyActiveRules) {\n    if (node.type === types.MEDIA_RULE) {\n      let matchMedia = node.selector.match(MEDIA_MATCH);\n      if (matchMedia) {\n        // if rule is a non matching @media rule, skip subrules\n        if (!window.matchMedia(matchMedia[1]).matches) {\n          skipRules = true;\n        }\n      }\n    }\n  }\n  if (node.type === types.STYLE_RULE) {\n    styleRuleCallback(node);\n  } else if (keyframesRuleCallback &&\n    node.type === types.KEYFRAMES_RULE) {\n    keyframesRuleCallback(node);\n  } else if (node.type === types.MIXIN_RULE) {\n    skipRules = true;\n  }\n  let r$ = node.rules;\n  if (r$ && !skipRules) {\n    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {\n      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n    }\n  }\n}\n\n// add a string of cssText to the document.\nexport function applyCss(cssText, moniker, target, contextNode) {\n  let style = createScopeStyle(cssText, moniker);\n  return applyStyle(style, target, contextNode);\n}\n\n/**\n * @param {Node} style\n * @param {?Node} target\n * @param {?Node} contextNode\n * @return {Node}\n */\nexport function applyStyle(style, target, contextNode) {\n  target = target || document.head;\n  let after = (contextNode && contextNode.nextSibling) ||\n  target.firstChild;\n  lastHeadApplyNode = style;\n  return target.insertBefore(style, after);\n}\n\nexport function createScopeStyle(cssText, moniker) {\n  let style = document.createElement('style');\n  if (moniker) {\n    style.setAttribute('scope', moniker);\n  }\n  style.textContent = cssText;\n  return style;\n}\n\nlet lastHeadApplyNode = null;\n\n// insert a comment node as a styling position placeholder.\nexport function applyStylePlaceHolder(moniker) {\n  let placeHolder = document.createComment(' Shady DOM styles for ' +\n    moniker + ' ');\n  let after = lastHeadApplyNode ?\n    lastHeadApplyNode['nextSibling'] : null;\n  let scope = document.head;\n  scope.insertBefore(placeHolder, after || scope.firstChild);\n  lastHeadApplyNode = placeHolder;\n  return placeHolder;\n}\n\nexport function isTargetedBuild(buildType) {\n  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';\n}\n\nexport function getCssBuildType(element) {\n  return element.getAttribute('css-build');\n}\n\n/**\n * Walk from text[start] matching parens and\n * returns position of the outer end paren\n * @param {string} text\n * @param {number} start\n * @return {number}\n */\nfunction findMatchingParen(text, start) {\n  let level = 0;\n  for (let i=start, l=text.length; i < l; i++) {\n    if (text[i] === '(') {\n      level++;\n    } else if (text[i] === ')') {\n      if (--level === 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nexport function processVariableAndFallback(str, callback) {\n  // find 'var('\n  let start = str.indexOf('var(');\n  if (start === -1) {\n    // no var?, everything is prefix\n    return callback(str, '', '', '');\n  }\n  //${prefix}var(${inner})${suffix}\n  let end = findMatchingParen(str, start + 3);\n  let inner = str.substring(start + 4, end);\n  let prefix = str.substring(0, start);\n  // suffix may have other variables\n  let suffix = processVariableAndFallback(str.substring(end + 1), callback);\n  let comma = inner.indexOf(',');\n  // value and fallback args should be trimmed to match in property lookup\n  if (comma === -1) {\n    // variable, no fallback\n    return callback(prefix, inner.trim(), '', suffix);\n  }\n  // var(${value},${fallback})\n  let value = inner.substring(0, comma).trim();\n  let fallback = inner.substring(comma + 1).trim();\n  return callback(prefix, value, fallback, suffix);\n}\n\nexport function setElementClassRaw(element, value) {\n  // use native setAttribute provided by ShadyDOM when setAttribute is patched\n  if (window['ShadyDOM']) {\n    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);\n  } else {\n    element.setAttribute('class', value);\n  }\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    @apply --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n\n'use strict';\n\nimport {forEachRule, processVariableAndFallback, rulesForStyle} from './style-util'\nimport {MIXIN_MATCH, VAR_ASSIGN} from './common-regex'\nimport {StyleNode} from './css-parse'\n\nconst APPLY_NAME_CLEAN = /;\\s*/m;\nconst INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\n// separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\nconst MIXIN_VAR_SEP = '_-_';\n\n/** @typedef {{\n *    properties: !Object<string, string>,\n *    dependants: !Object<string, boolean>\n * }}\n */\nlet MixinMapEntry;\n\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\nclass MixinMap {\n  constructor() {\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!MixinMapEntry} props\n   */\n  set(name, props) {\n    name = name.trim();\n    this._map[name] = {\n      properties: props,\n      dependants: {}\n    }\n  }\n  /**\n   * @param {string} name\n   * @return {MixinMapEntry}\n   */\n  get(name) {\n    name = name.trim();\n    return this._map[name] || null;\n  }\n}\n\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\nlet invalidCallback = null;\n\n/** @unrestricted */\nclass ApplyShim {\n  constructor() {\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n  detectMixin(cssText) {\n    const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText);\n    // reset state of the regexes\n    MIXIN_MATCH.lastIndex = 0;\n    VAR_ASSIGN.lastIndex = 0;\n    return has;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformStyle(style, elementName) {\n    let ast = rulesForStyle(style);\n    this.transformRules(ast, elementName);\n    return ast;\n  }\n  /**\n   * @param {StyleNode} rules\n   * @param {string} elementName\n   */\n  transformRules(rules, elementName) {\n    this._currentElement = elementName;\n    forEachRule(rules, (r) => {\n      this.transformRule(r);\n    });\n    this._currentElement = null;\n  }\n  /**\n   * @param {!StyleNode} rule\n   */\n  transformRule(rule) {\n    rule.cssText = this.transformCssText(/** @type {string} */(rule.parsedCssText));\n    // :root was only used for variable assignment in property shim,\n    // but generates invalid selectors with real properties.\n    // replace with `:host > *`, which serves the same effect\n    if (rule.selector === ':root') {\n      rule.selector = ':host > *';\n    }\n  }\n  /**\n   * @param {string} cssText\n   * @return {string}\n   */\n  transformCssText(cssText) {\n    // produce variables\n    cssText = cssText.replace(VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin) =>\n      this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin));\n    // consume mixins\n    return this._consumeCssProperties(cssText);\n  }\n  /**\n   * @param {string} property\n   * @return {string}\n   */\n  _getInitialValueForProperty(property) {\n    if (!this._measureElement) {\n      this._measureElement = /** @type {HTMLMetaElement} */(document.createElement('meta'));\n      this._measureElement.setAttribute('apply-shim-measure', '');\n      this._measureElement.style.all = 'initial';\n      document.head.appendChild(this._measureElement);\n    }\n    return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n  }\n  /**\n   * replace mixin consumption with variable consumption\n   * @param {string} text\n   * @return {string}\n   */\n  _consumeCssProperties(text) {\n    /** @type {Array} */\n    let m = null;\n    // loop over text until all mixins with defintions have been applied\n    while((m = MIXIN_MATCH.exec(text))) {\n      let matchText = m[0];\n      let mixinName = m[1];\n      let idx = m.index;\n      // collect properties before apply to be \"defaults\" if mixin might override them\n      // match includes a \"prefix\", so find the start and end positions of @apply\n      let applyPos = idx + matchText.indexOf('@apply');\n      let afterApplyPos = idx + matchText.length;\n      // find props defined before this @apply\n      let textBeforeApply = text.slice(0, applyPos);\n      let textAfterApply = text.slice(afterApplyPos);\n      let defaults = this._cssTextToMap(textBeforeApply);\n      let replacement = this._atApplyToCssProperties(mixinName, defaults);\n      // use regex match position to replace mixin, keep linear processing time\n      text = `${textBeforeApply}${replacement}${textAfterApply}`;\n      // move regex search to _after_ replacement\n      MIXIN_MATCH.lastIndex = idx + replacement.length;\n    }\n    return text;\n  }\n  /**\n   * produce variable consumption at the site of mixin consumption\n   * @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n   * Example:\n   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n   *\n   * @param {string} mixinName\n   * @param {Object} fallbacks\n   * @return {string}\n   */\n  _atApplyToCssProperties(mixinName, fallbacks) {\n    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n    let vars = [];\n    let mixinEntry = this._map.get(mixinName);\n    // if we depend on a mixin before it is created\n    // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n    if (!mixinEntry) {\n      this._map.set(mixinName, {});\n      mixinEntry = this._map.get(mixinName);\n    }\n    if (mixinEntry) {\n      if (this._currentElement) {\n        mixinEntry.dependants[this._currentElement] = true;\n      }\n      let p, parts, f;\n      for (p in mixinEntry.properties) {\n        f = fallbacks && fallbacks[p];\n        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n        if (f) {\n          parts.push(',', f);\n        }\n        parts.push(')');\n        vars.push(parts.join(''));\n      }\n    }\n    return vars.join('; ');\n  }\n\n  /**\n   * @param {string} property\n   * @param {string} value\n   * @return {string}\n   */\n  _replaceInitialOrInherit(property, value) {\n    let match = INITIAL_INHERIT.exec(value);\n    if (match) {\n      if (match[1]) {\n        // initial\n        // replace `initial` with the concrete initial value for this property\n        value = this._getInitialValueForProperty(property);\n      } else {\n        // inherit\n        // with this purposfully illegal value, the variable will be invalid at\n        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n        // and for inheriting values, will behave similarly\n        // we cannot support the same behavior for non inheriting values like 'border'\n        value = 'apply-shim-inherit';\n      }\n    }\n    return value;\n  }\n\n  /**\n   * \"parse\" a mixin definition into a map of properties and values\n   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n   * @param {string} text\n   * @return {!Object<string, string>}\n   */\n  _cssTextToMap(text) {\n    let props = text.split(';');\n    let property, value;\n    let out = {};\n    for (let i = 0, p, sp; i < props.length; i++) {\n      p = props[i];\n      if (p) {\n        sp = p.split(':');\n        // ignore lines that aren't definitions like @media\n        if (sp.length > 1) {\n          property = sp[0].trim();\n          // some properties may have ':' in the value, like data urls\n          value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n          out[property] = value;\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * @param {MixinMapEntry} mixinEntry\n   */\n  _invalidateMixinEntry(mixinEntry) {\n    if (!invalidCallback) {\n      return;\n    }\n    for (let elementName in mixinEntry.dependants) {\n      if (elementName !== this._currentElement) {\n        invalidCallback(elementName);\n      }\n    }\n  }\n\n  /**\n   * @param {string} matchText\n   * @param {string} propertyName\n   * @param {?string} valueProperty\n   * @param {?string} valueMixin\n   * @return {string}\n   */\n  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n    // handle case where property value is a mixin\n    if (valueProperty) {\n      // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n      processVariableAndFallback(valueProperty, (prefix, value) => {\n        if (value && this._map.get(value)) {\n          valueMixin = `@apply ${value};`\n        }\n      });\n    }\n    if (!valueMixin) {\n      return matchText;\n    }\n    let mixinAsProperties = this._consumeCssProperties(valueMixin);\n    let prefix = matchText.slice(0, matchText.indexOf('--'));\n    let mixinValues = this._cssTextToMap(mixinAsProperties);\n    let combinedProps = mixinValues;\n    let mixinEntry = this._map.get(propertyName);\n    let oldProps = mixinEntry && mixinEntry.properties;\n    if (oldProps) {\n      // NOTE: since we use mixin, the map of properties is updated here\n      // and this is what we want.\n      combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n    } else {\n      this._map.set(propertyName, combinedProps);\n    }\n    let out = [];\n    let p, v;\n    // set variables defined by current mixin\n    let needToInvalidate = false;\n    for (p in combinedProps) {\n      v = mixinValues[p];\n      // if property not defined by current mixin, set initial\n      if (v === undefined) {\n        v = 'initial';\n      }\n      if (oldProps && !(p in oldProps)) {\n        needToInvalidate = true;\n      }\n      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);\n    }\n    if (needToInvalidate) {\n      this._invalidateMixinEntry(mixinEntry);\n    }\n    if (mixinEntry) {\n      mixinEntry.properties = combinedProps;\n    }\n    // because the mixinMap is global, the mixin might conflict with\n    // a different scope's simple variable definition:\n    // Example:\n    // some style somewhere:\n    // --mixin1:{ ... }\n    // --mixin2: var(--mixin1);\n    // some other element:\n    // --mixin1: 10px solid red;\n    // --foo: var(--mixin1);\n    // In this case, we leave the original variable definition in place.\n    if (valueProperty) {\n      prefix = `${matchText};${prefix}`;\n    }\n    return `${prefix}${out.join('; ')};`;\n  }\n}\n\n/* exports */\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformCssText'] = ApplyShim.prototype.transformCssText;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get() {\n    return invalidCallback;\n  },\n  /** @param {?function(string)} cb */\n  set(cb) {\n    invalidCallback = cb;\n  }\n});\n\nwindow['ApplyShim'] = new ApplyShim();","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport * as StyleUtil from './style-util'\nimport {nativeShadow} from './style-settings'\n\n/* Transforms ShadowDOM styling into ShadyDOM styling\n\n* scoping:\n\n  * elements in scope get scoping selector class=\"x-foo-scope\"\n  * selectors re-written as follows:\n\n    div button -> div.x-foo-scope button.x-foo-scope\n\n* :host -> scopeName\n\n* :host(...) -> scopeName...\n\n* ::slotted(...) -> scopeName > ...\n\n* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\n* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\n*/\nconst SCOPE_NAME = 'style-scope';\n\nclass StyleTransformer {\n  get SCOPE_NAME() {\n    return SCOPE_NAME;\n  }\n  // Given a node and scope name, add a scoping class to each node\n  // in the tree. This facilitates transforming css into scoped rules.\n  dom(node, scope, shouldRemoveScope) {\n    // one time optimization to skip scoping...\n    if (node['__styleScoped']) {\n      node['__styleScoped'] = null;\n    } else {\n      this._transformDom(node, scope || '', shouldRemoveScope);\n    }\n  }\n\n  _transformDom(node, selector, shouldRemoveScope) {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      this.element(node, selector, shouldRemoveScope);\n    }\n    let c$ = (node.localName === 'template') ?\n      (node.content || node._content).childNodes :\n      node.children || node.childNodes;\n    if (c$) {\n      for (let i=0; i<c$.length; i++) {\n        this._transformDom(c$[i], selector, shouldRemoveScope);\n      }\n    }\n  }\n\n  element(element, scope, shouldRemoveScope) {\n    // note: if using classes, we add both the general 'style-scope' class\n    // as well as the specific scope. This enables easy filtering of all\n    // `style-scope` elements\n    if (scope) {\n      // note: svg on IE does not have classList so fallback to class\n      if (element.classList) {\n        if (shouldRemoveScope) {\n          element.classList.remove(SCOPE_NAME);\n          element.classList.remove(scope);\n        } else {\n          element.classList.add(SCOPE_NAME);\n          element.classList.add(scope);\n        }\n      } else if (element.getAttribute) {\n        let c = element.getAttribute(CLASS);\n        if (shouldRemoveScope) {\n          if (c) {\n            let newValue = c.replace(SCOPE_NAME, '').replace(scope, '');\n            StyleUtil.setElementClassRaw(element, newValue);\n          }\n        } else {\n          let newValue = (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope;\n          StyleUtil.setElementClassRaw(element, newValue);\n        }\n      }\n    }\n  }\n\n  elementStyles(element, styleRules, callback) {\n    let cssBuildType = element.__cssBuild;\n    // no need to shim selectors if settings.useNativeShadow, also\n    // a shady css build will already have transformed selectors\n    // NOTE: This method may be called as part of static or property shimming.\n    // When there is a targeted build it will not be called for static shimming,\n    // but when the property shim is used it is called and should opt out of\n    // static shimming work when a proper build exists.\n    let cssText = (nativeShadow || cssBuildType === 'shady') ?\n    StyleUtil.toCssText(styleRules, callback) :\n    this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n    return cssText.trim();\n  }\n\n  // Given a string of cssText and a scoping string (scope), returns\n  // a string of scoped css where each selector is transformed to include\n  // a class created from the scope. ShadowDOM selectors are also transformed\n  // (e.g. :host) to use the scoping selector.\n  css(rules, scope, ext, callback) {\n    let hostScope = this._calcHostScope(scope, ext);\n    scope = this._calcElementScope(scope);\n    let self = this;\n    return StyleUtil.toCssText(rules, function(rule) {\n      if (!rule.isScoped) {\n        self.rule(rule, scope, hostScope);\n        rule.isScoped = true;\n      }\n      if (callback) {\n        callback(rule, scope, hostScope);\n      }\n    });\n  }\n\n  _calcElementScope(scope) {\n    if (scope) {\n      return CSS_CLASS_PREFIX + scope;\n    } else {\n      return '';\n    }\n  }\n\n  _calcHostScope(scope, ext) {\n    return ext ? `[is=${scope}]` : scope;\n  }\n\n  rule(rule, scope, hostScope) {\n    this._transformRule(rule, this._transformComplexSelector,\n      scope, hostScope);\n  }\n\n  /**\n   * transforms a css rule to a scoped rule.\n   *\n   * @param {Object} rule\n   * @param {Function} transformer\n   * @param {string=} scope\n   * @param {string=} hostScope\n   */\n  _transformRule(rule, transformer, scope, hostScope) {\n    // NOTE: save transformedSelector for subsequent matching of elements\n    // against selectors (e.g. when calculating style properties)\n    rule.selector = rule.transformedSelector =\n      this._transformRuleCss(rule, transformer, scope, hostScope);\n  }\n\n  _transformRuleCss(rule, transformer, scope, hostScope) {\n    let p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n    // we want to skip transformation of rules that appear in keyframes,\n    // because they are keyframe selectors, not element selectors.\n    if (!StyleUtil.isKeyframesSelector(rule)) {\n      for (let i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n        p$[i] = transformer.call(this, p, scope, hostScope);\n      }\n    }\n    return p$.join(COMPLEX_SELECTOR_SEP);\n  }\n\n/**\n * @param {string} selector\n * @param {string} scope\n * @param {string=} hostScope\n */\n  _transformComplexSelector(selector, scope, hostScope) {\n    let stop = false;\n    selector = selector.trim();\n    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n    selector = selector.replace(NTH, (m, type, inner) => `:${type}(${inner.replace(/\\s/g, '')})`);\n    selector = selector.replace(SLOTTED_START, `${HOST} $1`);\n    selector = selector.replace(SIMPLE_SELECTOR_SEP, (m, c, s) => {\n      if (!stop) {\n        let info = this._transformCompoundSelector(s, c, scope, hostScope);\n        stop = stop || info.stop;\n        c = info.combinator;\n        s = info.value;\n      }\n      return c + s;\n    });\n    return selector;\n  }\n\n  _transformCompoundSelector(selector, combinator, scope, hostScope) {\n    // replace :host with host scoping class\n    let slottedIndex = selector.indexOf(SLOTTED);\n    if (selector.indexOf(HOST) >= 0) {\n      selector = this._transformHostSelector(selector, hostScope);\n    // replace other selectors with scoping class\n    } else if (slottedIndex !== 0) {\n      selector = scope ? this._transformSimpleSelector(selector, scope) :\n        selector;\n    }\n    // mark ::slotted() scope jump to replace with descendant selector + arg\n    // also ignore left-side combinator\n    let slotted = false;\n    if (slottedIndex >= 0) {\n      combinator = '';\n      slotted = true;\n    }\n    // process scope jumping selectors up to the scope jump and then stop\n    let stop;\n    if (slotted) {\n      stop = true;\n      if (slotted) {\n        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n        selector = selector.replace(SLOTTED_PAREN, (m, paren) => ` > ${paren}`);\n      }\n    }\n    selector = selector.replace(DIR_PAREN, (m, before, dir) =>\n      `[dir=\"${dir}\"] ${before}, ${before}[dir=\"${dir}\"]`);\n    return {value: selector, combinator, stop};\n  }\n\n  _transformSimpleSelector(selector, scope) {\n    let p$ = selector.split(PSEUDO_PREFIX);\n    p$[0] += scope;\n    return p$.join(PSEUDO_PREFIX);\n  }\n\n  // :host(...) -> scopeName...\n  _transformHostSelector(selector, hostScope) {\n    let m = selector.match(HOST_PAREN);\n    let paren = m && m[2].trim() || '';\n    if (paren) {\n      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n        // paren starts with a type selector\n        let typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n        // if the type selector is our hostScope then avoid pre-pending it\n        if (typeSelector === hostScope) {\n          return paren;\n        // otherwise, this selector should not match in this scope so\n        // output a bogus selector.\n        } else {\n          return SELECTOR_NO_MATCH;\n        }\n      } else {\n        // make sure to do a replace here to catch selectors like:\n        // `:host(.foo)::before`\n        return selector.replace(HOST_PAREN, function(m, host, paren) {\n          return hostScope + paren;\n        });\n      }\n    // if no paren, do a straight :host replacement.\n    // TODO(sorvell): this should not strictly be necessary but\n    // it's needed to maintain support for `:host[foo]` type selectors\n    // which have been improperly used under Shady DOM. This should be\n    // deprecated.\n    } else {\n      return selector.replace(HOST, hostScope);\n    }\n  }\n\n  documentRule(rule) {\n    // reset selector in case this is redone.\n    rule.selector = rule.parsedSelector;\n    this.normalizeRootSelector(rule);\n    this._transformRule(rule, this._transformDocumentSelector);\n  }\n\n  normalizeRootSelector(rule) {\n    if (rule.selector === ROOT) {\n      rule.selector = 'html';\n    }\n  }\n\n/**\n * @param {string} selector\n */\n  _transformDocumentSelector(selector) {\n    return selector.match(SLOTTED) ?\n      this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) :\n      this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n  }\n}\n\nlet NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\nlet SCOPE_DOC_SELECTOR = `:not(.${SCOPE_NAME})`;\nlet COMPLEX_SELECTOR_SEP = ',';\nlet SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\nlet SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\nlet HOST = ':host';\nlet ROOT = ':root';\nlet SLOTTED = '::slotted';\nlet SLOTTED_START = new RegExp(`^(${SLOTTED})`);\n// NOTE: this supports 1 nested () pair for things like\n// :host(:not([selected]), more general support requires\n// parsing which seems like overkill\nlet HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n// similar to HOST_PAREN\nlet SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\nlet DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\nlet CSS_CLASS_PREFIX = '.';\nlet PSEUDO_PREFIX = ':';\nlet CLASS = 'class';\nlet SELECTOR_NO_MATCH = 'should_not_match';\n\nexport default new StyleTransformer()","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {nativeShadow} from './style-settings'\nimport StyleTransformer from './style-transformer'\n\nexport let flush = function() {};\n\nif (!nativeShadow) {\n  let elementNeedsScoping = (element) => {\n    return (element.classList &&\n      !element.classList.contains(StyleTransformer.SCOPE_NAME) ||\n      // note: necessary for IE11\n      (element instanceof window['SVGElement'] && (!element.hasAttribute('class') ||\n      element.getAttribute('class').indexOf(StyleTransformer.SCOPE_NAME) < 0)));\n  }\n\n/**\n * @param {Array<MutationRecord|null>|null} mxns\n */\n  let handler = (mxns) => {\n    for (let x=0; x < mxns.length; x++) {\n      let mxn = mxns[x];\n      if (mxn.target === document.documentElement ||\n        mxn.target === document.head) {\n        continue;\n      }\n      for (let i=0; i < mxn.addedNodes.length; i++) {\n        let n = mxn.addedNodes[i];\n        if (elementNeedsScoping(n)) {\n          let root = n.getRootNode();\n          if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            // may no longer be in a shadowroot\n            let host = /** @type {ShadowRoot} */(root).host;\n            if (host) {\n              let scope = host.is || host.localName;\n              StyleTransformer.dom(n, scope);\n            }\n          }\n        }\n      }\n      for (let i=0; i < mxn.removedNodes.length; i++) {\n        let n = /** @type {HTMLElement} */(mxn.removedNodes[i]);\n        if (n.nodeType === Node.ELEMENT_NODE) {\n          let classes = undefined;\n          if (n.classList) {\n            classes = Array.from(n.classList);\n          } else if (n.hasAttribute('class')) {\n            classes = n.getAttribute('class').split(/\\s+/);\n          }\n          if (classes !== undefined) {\n            // NOTE: relies on the scoping class always being adjacent to the\n            // SCOPE_NAME class.\n            let classIdx = classes.indexOf(StyleTransformer.SCOPE_NAME);\n            if (classIdx >= 0) {\n              let scope = classes[classIdx + 1];\n              if (scope) {\n                StyleTransformer.dom(n, scope, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  let observer = new MutationObserver(handler);\n  let start = (node) => {\n    observer.observe(node, {childList: true, subtree: true});\n  }\n  let nativeCustomElements = (window.customElements &&\n    !window['customElements']['flush']);\n  // need to start immediately with native custom elements\n  // TODO(dfreedm): with polyfilled HTMLImports and native custom elements\n  // excessive mutations may be observed; this can be optimized via cooperation\n  // with the HTMLImports polyfill.\n  if (nativeCustomElements) {\n    start(document);\n  } else {\n    let delayedStart = () => {\n      start(document.body);\n    }\n    // use polyfill timing if it's available\n    if (window['HTMLImports']) {\n      window['HTMLImports']['whenReady'](delayedStart);\n    // otherwise push beyond native imports being ready\n    // which requires RAF + readystate interactive.\n    } else {\n      requestAnimationFrame(function() {\n        if (document.readyState === 'loading') {\n          let listener = function() {\n            delayedStart();\n            document.removeEventListener('readystatechange', listener);\n          }\n          document.addEventListener('readystatechange', listener);\n        } else {\n          delayedStart();\n        }\n      });\n    }\n  }\n\n  flush = function() {\n    handler(observer.takeRecords());\n  }\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nexport default {};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport templateMap from './template-map'\nimport {StyleNode} from './css-parse'\n\n/**\n * @const {Promise}\n */\nconst promise = Promise.resolve();\n\n/**\n * @const {string}\n */\nconst infoKey = '__styleInfo';\n\nexport default class StyleInfo {\n  static get(node) {\n    return node[infoKey];\n  }\n  static set(node, styleInfo) {\n    node[infoKey] = styleInfo;\n    return styleInfo;\n  }\n  static invalidate(elementName) {\n    if (templateMap[elementName]) {\n      templateMap[elementName]._applyShimInvalid = true;\n    }\n  }\n  /*\n  the template is marked as `validating` for one microtask so that all instances\n  found in the tree crawl of `applyStyle` will update themselves,\n  but the template will only be updated once.\n  */\n  static startValidating(elementName) {\n    /**\n     * @const {Element|undefined}\n     */\n    const template = templateMap[elementName];\n    if (!template._validating) {\n      template._validating = true;\n      promise.then(() => {\n        template._applyShimInvalid = false;\n        template._validating = false;\n      });\n    }\n  }\n  constructor(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n    /** @type {?StyleNode} */\n    this.styleRules = ast || null;\n    /** @type {?Node} */\n    this.placeholder = placeholder || null;\n    /** @type {!Array<string>} */\n    this.ownStylePropertyNames = ownStylePropertyNames || [];\n    /** @type {?Array<Object>} */\n    this.overrideStyleProperties = null;\n    /** @type {string} */\n    this.elementName = elementName || '';\n    /** @type {string} */\n    this.cssBuild = cssBuild || '';\n    /** @type {string} */\n    this.typeExtension = typeExtension || '';\n    /** @type {?Array<Object>} */\n    this.styleProperties = null;\n    /** @type {?string} */\n    this.scopeSelector = null;\n    /** @type {?Node} */\n    this.customStyle = null;\n  }\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {removeCustomPropAssignment, StyleNode} from './css-parse'\nimport {nativeShadow} from './style-settings'\nimport StyleTransformer from './style-transformer'\nimport * as StyleUtil from './style-util'\nimport * as RX from './common-regex'\nimport StyleInfo from './style-info'\n\n// TODO: dedupe with shady\n/**\n * @const {function(string):boolean}\n */\nconst matchesSelector = ((p) => p.matches || p.matchesSelector ||\n  p.mozMatchesSelector || p.msMatchesSelector ||\np.oMatchesSelector || p.webkitMatchesSelector)(window.Element.prototype);\n\nconst IS_IE = navigator.userAgent.match('Trident');\n\nconst XSCOPE_NAME = 'x-scope';\n\nclass StyleProperties {\n  get XSCOPE_NAME() {\n    return XSCOPE_NAME;\n  }\n  // decorates styles with rule info and returns an array of used style\n  // property names\n  decorateStyles(rules) {\n    let self = this, props = {}, keyframes = [], ruleIndex = 0;\n    StyleUtil.forEachRule(rules, function(rule) {\n      self.decorateRule(rule);\n      // mark in-order position of ast rule in styles block, used for cache key\n      rule.index = ruleIndex++;\n      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n    }, function onKeyframesRule(rule) {\n      keyframes.push(rule);\n    });\n    // Cache all found keyframes rules for later reference:\n    rules._keyframes = keyframes;\n    // return this list of property names *consumes* in these styles.\n    let names = [];\n    for (let i in props) {\n      names.push(i);\n    }\n    return names;\n  }\n\n  // decorate a single rule with property info\n  decorateRule(rule) {\n    if (rule.propertyInfo) {\n      return rule.propertyInfo;\n    }\n    let info = {}, properties = {};\n    let hasProperties = this.collectProperties(rule, properties);\n    if (hasProperties) {\n      info.properties = properties;\n      // TODO(sorvell): workaround parser seeing mixins as additional rules\n      rule.rules = null;\n    }\n    info.cssText = this.collectCssText(rule);\n    rule.propertyInfo = info;\n    return info;\n  }\n\n  // collects the custom properties from a rule's cssText\n  collectProperties(rule, properties) {\n    let info = rule.propertyInfo;\n    if (info) {\n      if (info.properties) {\n        Object.assign(properties, info.properties);\n        return true;\n      }\n    } else {\n      let m, rx = RX.VAR_ASSIGN;\n      let cssText = rule.parsedCssText;\n      let value;\n      let any;\n      while ((m = rx.exec(cssText))) {\n        // note: group 2 is var, 3 is mixin\n        value = (m[2] || m[3]).trim();\n        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n        if (value !== 'inherit' || value !== 'unset') {\n          properties[m[1].trim()] = value;\n        }\n        any = true;\n      }\n      return any;\n    }\n\n  }\n\n  // returns cssText of properties that consume variables/mixins\n  collectCssText(rule) {\n    return this.collectConsumingCssText(rule.parsedCssText);\n  }\n\n  // NOTE: we support consumption inside mixin assignment\n  // but not production, so strip out {...}\n  collectConsumingCssText(cssText) {\n    return cssText.replace(RX.BRACKETED, '')\n      .replace(RX.VAR_ASSIGN, '');\n  }\n\n  collectPropertiesInCssText(cssText, props) {\n    let m;\n    while ((m = RX.VAR_CONSUMED.exec(cssText))) {\n      let name = m[1];\n      // This regex catches all variable names, and following non-whitespace char\n      // If next char is not ':', then variable is a consumer\n      if (m[2] !== ':') {\n        props[name] = true;\n      }\n    }\n  }\n\n  // turns custom properties into realized values.\n  reify(props) {\n    // big perf optimization here: reify only *own* properties\n    // since this object has __proto__ of the element's scope properties\n    let names = Object.getOwnPropertyNames(props);\n    for (let i=0, n; i < names.length; i++) {\n      n = names[i];\n      props[n] = this.valueForProperty(props[n], props);\n    }\n  }\n\n  // given a property value, returns the reified value\n  // a property value may be:\n  // (1) a literal value like: red or 5px;\n  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n  // var(--a, var(--b));\n  // (3) a literal mixin value like { properties }. Each of these properties\n  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n  valueForProperty(property, props) {\n    // case (1) default\n    // case (3) defines a mixin and we have to reify the internals\n    if (property) {\n      if (property.indexOf(';') >=0) {\n        property = this.valueForProperties(property, props);\n      } else {\n        // case (2) variable\n        let self = this;\n        let fn = function(prefix, value, fallback, suffix) {\n          if (!value) {\n            return prefix + suffix;\n          }\n          let propertyValue = self.valueForProperty(props[value], props);\n          // if value is \"initial\", then the variable should be treated as unset\n          if (!propertyValue || propertyValue === 'initial') {\n            // fallback may be --a or var(--a) or literal\n            propertyValue = self.valueForProperty(props[fallback] || fallback, props) ||\n            fallback;\n          } else if (propertyValue === 'apply-shim-inherit') {\n            // CSS build will replace `inherit` with `apply-shim-inherit`\n            // for use with native css variables.\n            // Since we have full control, we can use `inherit` directly.\n            propertyValue = 'inherit';\n          }\n          return prefix + (propertyValue || '') + suffix;\n        };\n        property = StyleUtil.processVariableAndFallback(property, fn);\n      }\n    }\n    return property && property.trim() || '';\n  }\n\n  // note: we do not yet support mixin within mixin\n  valueForProperties(property, props) {\n    let parts = property.split(';');\n    for (let i=0, p, m; i<parts.length; i++) {\n      if ((p = parts[i])) {\n        RX.MIXIN_MATCH.lastIndex = 0;\n        m = RX.MIXIN_MATCH.exec(p);\n        if (m) {\n          p = this.valueForProperty(props[m[1]], props);\n        } else {\n          let colon = p.indexOf(':');\n          if (colon !== -1) {\n            let pp = p.substring(colon);\n            pp = pp.trim();\n            pp = this.valueForProperty(pp, props) || pp;\n            p = p.substring(0, colon) + pp;\n          }\n        }\n        parts[i] = (p && p.lastIndexOf(';') === p.length - 1) ?\n          // strip trailing ;\n          p.slice(0, -1) :\n          p || '';\n      }\n    }\n    return parts.join(';');\n  }\n\n  applyProperties(rule, props) {\n    let output = '';\n    // dynamically added sheets may not be decorated so ensure they are.\n    if (!rule.propertyInfo) {\n      this.decorateRule(rule);\n    }\n    if (rule.propertyInfo.cssText) {\n      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n    }\n    rule.cssText = output;\n  }\n\n  // Apply keyframe transformations to the cssText of a given rule. The\n  // keyframeTransforms object is a map of keyframe names to transformer\n  // functions which take in cssText and spit out transformed cssText.\n  applyKeyframeTransforms(rule, keyframeTransforms) {\n    let input = rule.cssText;\n    let output = rule.cssText;\n    if (rule.hasAnimations == null) {\n      // Cache whether or not the rule has any animations to begin with:\n      rule.hasAnimations = RX.ANIMATION_MATCH.test(input);\n    }\n    // If there are no animations referenced, we can skip transforms:\n    if (rule.hasAnimations) {\n      let transform;\n      // If we haven't transformed this rule before, we iterate over all\n      // transforms:\n      if (rule.keyframeNamesToTransform == null) {\n        rule.keyframeNamesToTransform = [];\n        for (let keyframe in keyframeTransforms) {\n          transform = keyframeTransforms[keyframe];\n          output = transform(input);\n          // If the transform actually changed the CSS text, we cache the\n          // transform name for future use:\n          if (input !== output) {\n            input = output;\n            rule.keyframeNamesToTransform.push(keyframe);\n          }\n        }\n      } else {\n        // If we already have a list of keyframe names that apply to this\n        // rule, we apply only those keyframe name transforms:\n        for (let i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n          input = transform(input);\n        }\n        output = input;\n      }\n    }\n    rule.cssText = output;\n  }\n\n  // Test if the rules in these styles matches the given `element` and if so,\n  // collect any custom properties into `props`.\n  propertyDataFromStyles(rules, element) {\n    let props = {}, self = this;\n    // generates a unique key for these matches\n    let o = [];\n    // note: active rules excludes non-matching @media rules\n    StyleUtil.forEachRule(rules, function(rule) {\n      // TODO(sorvell): we could trim the set of rules at declaration\n      // time to only include ones that have properties\n      if (!rule.propertyInfo) {\n        self.decorateRule(rule);\n      }\n      // match element against transformedSelector: selector may contain\n      // unwanted uniquification and parsedSelector does not directly match\n      // for :host selectors.\n      let selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n      if (element && rule.propertyInfo.properties && selectorToMatch) {\n        if (matchesSelector.call(element, selectorToMatch)) {\n          self.collectProperties(rule, props);\n          // produce numeric key for these matches for lookup\n          addToBitMask(rule.index, o);\n        }\n      }\n    }, null, true);\n    return {properties: props, key: o};\n  }\n\n  whenHostOrRootRule(scope, rule, cssBuild, callback) {\n    if (!rule.propertyInfo) {\n      this.decorateRule(rule);\n    }\n    if (!rule.propertyInfo.properties) {\n      return;\n    }\n    let hostScope = scope.is ?\n    StyleTransformer._calcHostScope(scope.is, scope.extends) :\n    'html';\n    let parsedSelector = rule.parsedSelector;\n    let isRoot = (parsedSelector === ':host > *' || parsedSelector === 'html');\n    let isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n    // build info is either in scope (when scope is an element) or in the style\n    // when scope is the default scope; note: this allows default scope to have\n    // mixed mode built and unbuilt styles.\n    if (cssBuild === 'shady') {\n      // :root -> x-foo > *.x-foo for elements and html for custom-style\n      isRoot = parsedSelector === (hostScope + ' > *.' + hostScope) || parsedSelector.indexOf('html') !== -1;\n      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n    }\n    if (cssBuild === 'shadow') {\n      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n      isHost = isHost && !isRoot;\n    }\n    if (!isRoot && !isHost) {\n      return;\n    }\n    let selectorToMatch = hostScope;\n    if (isHost) {\n      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n      if (nativeShadow && !rule.transformedSelector) {\n        // transform :host into a matchable selector\n        rule.transformedSelector =\n        StyleTransformer._transformRuleCss(\n          rule,\n          StyleTransformer._transformComplexSelector,\n          StyleTransformer._calcElementScope(scope.is),\n          hostScope\n        );\n      }\n      selectorToMatch = rule.transformedSelector || hostScope;\n    }\n    callback({\n      selector: selectorToMatch,\n      isHost: isHost,\n      isRoot: isRoot\n    });\n  }\n/**\n * @param {string} scope\n * @param {StyleNode} rules\n * @return {Object}\n */\n  hostAndRootPropertiesForScope(scope, rules) {\n    let hostProps = {}, rootProps = {}, self = this;\n    // note: active rules excludes non-matching @media rules\n    let cssBuild = rules && rules.__cssBuild;\n    StyleUtil.forEachRule(rules, function(rule) {\n      // if scope is StyleDefaults, use _element for matchesSelector\n      self.whenHostOrRootRule(scope, rule, cssBuild, function(info) {\n        let element = scope._element || scope;\n        if (matchesSelector.call(element, info.selector)) {\n          if (info.isHost) {\n            self.collectProperties(rule, hostProps);\n          } else {\n            self.collectProperties(rule, rootProps);\n          }\n        }\n      });\n    }, null, true);\n    return {rootProps: rootProps, hostProps: hostProps};\n  }\n\n  transformStyles(element, properties, scopeSelector) {\n    let self = this;\n    let hostSelector = StyleTransformer\n      ._calcHostScope(element.is, element.extends);\n    let rxHostSelector = element.extends ?\n      '\\\\' + hostSelector.slice(0, -1) + '\\\\]' :\n      hostSelector;\n    let hostRx = new RegExp(RX.HOST_PREFIX + rxHostSelector +\n      RX.HOST_SUFFIX);\n    let rules = StyleInfo.get(element).styleRules;\n    let keyframeTransforms =\n      this._elementKeyframeTransforms(element, rules, scopeSelector);\n    return StyleTransformer.elementStyles(element, rules, function(rule) {\n      self.applyProperties(rule, properties);\n      if (!nativeShadow &&\n          !StyleUtil.isKeyframesSelector(rule) &&\n          rule.cssText) {\n        // NOTE: keyframe transforms only scope munge animation names, so it\n        // is not necessary to apply them in ShadowDOM.\n        self.applyKeyframeTransforms(rule, keyframeTransforms);\n        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n      }\n    });\n  }\n\n  _elementKeyframeTransforms(element, rules, scopeSelector) {\n    let keyframesRules = rules._keyframes;\n    let keyframeTransforms = {};\n    if (!nativeShadow && keyframesRules) {\n      // For non-ShadowDOM, we transform all known keyframes rules in\n      // advance for the current scope. This allows us to catch keyframes\n      // rules that appear anywhere in the stylesheet:\n      for (let i = 0, keyframesRule = keyframesRules[i];\n           i < keyframesRules.length;\n           keyframesRule = keyframesRules[++i]) {\n        this._scopeKeyframes(keyframesRule, scopeSelector);\n        keyframeTransforms[keyframesRule.keyframesName] =\n            this._keyframesRuleTransformer(keyframesRule);\n      }\n    }\n    return keyframeTransforms;\n  }\n\n  // Generate a factory for transforming a chunk of CSS text to handle a\n  // particular scoped keyframes rule.\n  _keyframesRuleTransformer(keyframesRule) {\n    return function(cssText) {\n      return cssText.replace(\n          keyframesRule.keyframesNameRx,\n          keyframesRule.transformedKeyframesName);\n    };\n  }\n\n  // Transforms `@keyframes` names to be unique for the current host.\n  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n  _scopeKeyframes(rule, scopeId) {\n    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n    rule.transformedSelector = rule.transformedSelector || rule.selector;\n    rule.selector = rule.transformedSelector.replace(\n        rule.keyframesName, rule.transformedKeyframesName);\n  }\n\n  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n  // host selector: x-foo.wide -> .x-foo-42.wide\n  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n  // (x-foo) to scope :host rules; this helps make property host rules\n  // have low specificity. They are overrideable by class selectors but,\n  // unfortunately, not by type selectors (e.g. overriding via\n  // `.special` is ok, but not by `x-foo`).\n  _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n    rule.transformedSelector = rule.transformedSelector || rule.selector;\n    let selector = rule.transformedSelector;\n    let scope = '.' + scopeId;\n    let parts = selector.split(',');\n    for (let i=0, l=parts.length, p; (i<l) && (p=parts[i]); i++) {\n      parts[i] = p.match(hostRx) ?\n        p.replace(hostSelector, scope) :\n        scope + ' ' + p;\n    }\n    rule.selector = parts.join(',');\n  }\n\n  applyElementScopeSelector(element, selector, old) {\n    let c = element.getAttribute('class') || '';\n    let v = c;\n    if (old) {\n      v = c.replace(\n        new RegExp('\\\\s*' + XSCOPE_NAME + '\\\\s*' + old + '\\\\s*', 'g'), ' ');\n    }\n    v += (v ? ' ' : '') + XSCOPE_NAME + ' ' + selector;\n    if (c !== v) {\n      StyleUtil.setElementClassRaw(element, v);\n    }\n  }\n\n  applyElementStyle(element, properties, selector, style) {\n    // calculate cssText to apply\n    let cssText = style ? style.textContent || '' :\n      this.transformStyles(element, properties, selector);\n    // if shady and we have a cached style that is not style, decrement\n    let styleInfo = StyleInfo.get(element);\n    let s = styleInfo.customStyle;\n    if (s && !nativeShadow && (s !== style)) {\n      s['_useCount']--;\n      if (s['_useCount'] <= 0 && s.parentNode) {\n        s.parentNode.removeChild(s);\n      }\n    }\n    // apply styling always under native or if we generated style\n    // or the cached style is not in document(!)\n    if (nativeShadow) {\n      // update existing style only under native\n      if (styleInfo.customStyle) {\n        styleInfo.customStyle.textContent = cssText;\n        style = styleInfo.customStyle;\n      // otherwise, if we have css to apply, do so\n      } else if (cssText) {\n        // apply css after the scope style of the element to help with\n        // style precedence rules.\n        style = StyleUtil.applyCss(cssText, selector, element['shadowRoot'],\n          styleInfo.placeholder);\n      }\n    } else {\n      // shady and no cache hit\n      if (!style) {\n        // apply css after the scope style of the element to help with\n        // style precedence rules.\n        if (cssText) {\n          style = StyleUtil.applyCss(cssText, selector, null,\n            styleInfo.placeholder);\n        }\n      // shady and cache hit but not in document\n      } else if (!style.parentNode) {\n        StyleUtil.applyStyle(style, null, styleInfo.placeholder);\n      }\n\n    }\n    // ensure this style is our custom style and increment its use count.\n    if (style) {\n      style['_useCount'] = style['_useCount'] || 0;\n      // increment use count if we changed styles\n      if (styleInfo.customStyle != style) {\n        style['_useCount']++;\n      }\n      styleInfo.customStyle = style;\n    }\n    // @media rules may be stale in IE 10 and 11\n    if (IS_IE) {\n      style.textContent = style.textContent;\n    }\n    return style;\n  }\n\n  applyCustomStyle(style, properties) {\n    let rules = StyleUtil.rulesForStyle(style);\n    let self = this;\n    style.textContent = StyleUtil.toCssText(rules, function(rule) {\n      let css = rule.cssText = rule.parsedCssText;\n      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n        // remove property assignments\n        // so next function isn't confused\n        // NOTE: we have 3 categories of css:\n        // (1) normal properties,\n        // (2) custom property assignments (--foo: red;),\n        // (3) custom property usage: border: var(--foo); @apply(--foo);\n        // In elements, 1 and 3 are separated for efficiency; here they\n        // are not and this makes this case unique.\n        css = removeCustomPropAssignment(css);\n        // replace with reified properties, scenario is same as mixin\n        rule.cssText = self.valueForProperties(css, properties);\n      }\n    });\n  }\n}\n\nfunction addToBitMask(n, bits) {\n  let o = parseInt(n / 32, 10);\n  let v = 1 << (n % 32);\n  bits[o] = (bits[o] || 0) | v;\n}\n\nexport default new StyleProperties();","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {applyStylePlaceHolder} from './style-util'\nimport {nativeShadow} from './style-settings'\n\nlet placeholderMap = {};\n\n/**\n * @const {Object|undefined}\n */\nconst ce = window['customElements'];\nif (ce && !nativeShadow) {\n  /**\n   * @const {function(string,Function,Object=)}\n   */\n  const origDefine = ce['define'];\n  ce['define'] = function(name, clazz, options) {\n    placeholderMap[name] = applyStylePlaceHolder(name);\n    return origDefine.call(ce, name, clazz, options);\n  };\n}\n\nexport default placeholderMap;\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {parse} from './css-parse'\nimport {nativeShadow, nativeCssVariables} from './style-settings'\nimport StyleTransformer from './style-transformer'\nimport * as StyleUtil from './style-util'\nimport StyleProperties from './style-properties'\nimport placeholderMap from './style-placeholder'\nimport StyleInfo from './style-info'\nimport StyleCache from './style-cache'\nimport {flush as watcherFlush} from './document-watcher'\nimport templateMap from './template-map';\n\nimport './apply-shim';\n/** @const {ApplyShim} */\nconst ApplyShim = window['ApplyShim'];\n\nApplyShim['invalidCallback'] = StyleInfo.invalidate;\n\n/**\n * @const {StyleCache}\n */\nconst styleCache = new StyleCache();\n\n/** @unrestricted */\nclass ShadyCSS {\n  constructor() {\n    this._scopeCounter = {};\n    this._documentOwner = document.documentElement;\n    this._documentOwnerStyleInfo = StyleInfo.set(document.documentElement, new StyleInfo({rules: []}));\n    this['_elementsHaveApplied'] = false;\n  }\n  flush() {\n    watcherFlush();\n  }\n  _generateScopeSelector(name) {\n    let id = this._scopeCounter[name] = (this._scopeCounter[name] || 0) + 1;\n    return `${name}-${id}`;\n  }\n  getStyleAst(style) {\n    return StyleUtil.rulesForStyle(style);\n  }\n  styleAstToString(ast) {\n    return StyleUtil.toCssText(ast);\n  }\n  _gatherStyles(template) {\n    let styles = template.content.querySelectorAll('style');\n    let cssText = [];\n    for (let i = 0; i < styles.length; i++) {\n      let s = styles[i];\n      cssText.push(s.textContent);\n      s.parentNode.removeChild(s);\n    }\n    return cssText.join('').trim();\n  }\n  _getCssBuild(template) {\n    let style = template.content.querySelector('style');\n    if (!style) {\n      return '';\n    }\n    return style.getAttribute('css-build') || '';\n  }\n  /**\n   * Prepare the styling and template for the given element type\n   *\n   * @param {HTMLTemplateElement} template\n   * @param {string} elementName\n   * @param {string=} typeExtension\n   */\n  prepareTemplate(template, elementName, typeExtension) {\n    if (template._prepared) {\n      return;\n    }\n    template._prepared = true;\n    template.name = elementName;\n    template.extends = typeExtension;\n    templateMap[elementName] = template;\n    let cssBuild = this._getCssBuild(template);\n    let cssText = this._gatherStyles(template);\n    let info = {\n      is: elementName,\n      extends: typeExtension,\n      __cssBuild: cssBuild,\n    };\n    if (!nativeShadow) {\n      StyleTransformer.dom(template.content, elementName);\n    }\n    // check if the styling has mixin definitions or uses\n    let hasMixins = ApplyShim.detectMixin(cssText);\n    let ast = parse(cssText);\n    // only run the applyshim transforms if there is a mixin involved\n    if (hasMixins && nativeCssVariables) {\n      ApplyShim.transformRules(ast, elementName);\n    }\n    template._styleAst = ast;\n    template._cssBuild = cssBuild;\n\n    let ownPropertyNames = [];\n    if (!nativeCssVariables) {\n      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n    }\n    if (!ownPropertyNames.length || nativeCssVariables) {\n      let root = nativeShadow ? template.content : null;\n      let placeholder = placeholderMap[elementName];\n      let style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n      template._style = style;\n    }\n    template._ownPropertyNames = ownPropertyNames;\n  }\n  _generateStaticStyle(info, rules, shadowroot, placeholder) {\n    let cssText = StyleTransformer.elementStyles(info, rules);\n    if (cssText.length) {\n      return StyleUtil.applyCss(cssText, info.is, shadowroot, placeholder);\n    }\n  }\n  _prepareHost(host) {\n    let is = host.getAttribute('is') || host.localName;\n    let typeExtension;\n    if (is !== host.localName) {\n      typeExtension = host.localName;\n    }\n    let placeholder = placeholderMap[is];\n    let template = templateMap[is];\n    let ast;\n    let ownStylePropertyNames;\n    let cssBuild;\n    if (template) {\n      ast = template._styleAst;\n      ownStylePropertyNames = template._ownPropertyNames;\n      cssBuild = template._cssBuild;\n    }\n    return StyleInfo.set(host,\n      new StyleInfo(\n        ast,\n        placeholder,\n        ownStylePropertyNames,\n        is,\n        typeExtension,\n        cssBuild\n      )\n    );\n  }\n  /**\n   * Apply styles for the given element\n   *\n   * @param {!HTMLElement} host\n   * @param {Object=} overrideProps\n   */\n  applyStyle(host, overrideProps) {\n    let is = host.getAttribute('is') || host.localName;\n    let styleInfo = StyleInfo.get(host);\n    let hasApplied = Boolean(styleInfo);\n    if (!styleInfo) {\n      styleInfo = this._prepareHost(host);\n    }\n    // Only trip the `elementsHaveApplied` flag if a node other that the root document has `applyStyle` called\n    if (!this._isRootOwner(host)) {\n      this['_elementsHaveApplied'] = true;\n    }\n    if (window['CustomStyle']) {\n      let CS = window['CustomStyle'];\n      if (CS['_documentDirty']) {\n        CS['findStyles']();\n        let customStyles = CS['_customStyles'];\n        if (!nativeCssVariables) {\n          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n        } else {\n          this._revalidateCustomStyleApplyShim(customStyles);\n        }\n        this._applyCustomStyles(customStyles);\n        // if no elements have booted yet, we can just update the document and be done\n        if (!this['_elementsHaveApplied']) {\n          return;\n        }\n        // if no native css custom properties, we must recalculate the whole tree\n        if (!nativeCssVariables) {\n          this.updateStyles();\n          /*\n          When updateStyles() runs, this element may not have a shadowroot yet.\n          If not, we need to make sure that this element runs `applyStyle` on itself at least once to generate a style\n          */\n          if (hasApplied) {\n            return;\n          }\n        }\n      }\n    }\n    if (overrideProps) {\n      styleInfo.overrideStyleProperties =\n        styleInfo.overrideStyleProperties || {};\n      Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n    }\n    if (nativeCssVariables) {\n      if (styleInfo.overrideStyleProperties) {\n        this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n      }\n      let template = templateMap[is];\n      // bail early if there is no shadowroot for this element\n      if (!template && !this._isRootOwner(host)) {\n        return;\n      }\n      if (template && template._applyShimInvalid && template._style) {\n        // update template\n        if (!template._validating) {\n          ApplyShim.transformRules(template._styleAst, is);\n          template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n          StyleInfo.startValidating(is);\n        }\n        // update instance if native shadowdom\n        if (nativeShadow) {\n          let root = host.shadowRoot;\n          if (root) {\n            let style = root.querySelector('style');\n            style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n          }\n        }\n        styleInfo.styleRules = template._styleAst;\n      }\n    } else {\n      this._updateProperties(host, styleInfo);\n      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n        this._applyStyleProperties(host, styleInfo);\n      }\n    }\n    if (hasApplied) {\n      let root = this._isRootOwner(host) ? host : host.shadowRoot;\n      // note: some elements may not have a root!\n      if (root) {\n        this._applyToDescendants(root);\n      }\n    }\n  }\n  _applyToDescendants(root) {\n    let c$ = root.children;\n    for (let i = 0, c; i < c$.length; i++) {\n      c = c$[i];\n      if (c.shadowRoot) {\n        this.applyStyle(c);\n      }\n      this._applyToDescendants(c);\n    }\n  }\n  _styleOwnerForNode(node) {\n    let root = node.getRootNode();\n    let host = root.host;\n    if (host) {\n      if (StyleInfo.get(host)) {\n        return host;\n      } else {\n        return this._styleOwnerForNode(host);\n      }\n    }\n    return this._documentOwner;\n  }\n  _isRootOwner(node) {\n    return (node === this._documentOwner);\n  }\n  _applyStyleProperties(host, styleInfo) {\n    let is = host.getAttribute('is') || host.localName;\n    let cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n    let cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n    let cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n    let oldScopeSelector = styleInfo.scopeSelector;\n    // only generate new scope if cached style is not found\n    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n    let style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n    if (!nativeShadow) {\n      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n    }\n    if (!cacheEntry) {\n      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n    }\n    return style;\n  }\n  _updateProperties(host, styleInfo) {\n    let owner = this._styleOwnerForNode(host);\n    let ownerStyleInfo = StyleInfo.get(owner);\n    let ownerProperties = ownerStyleInfo.styleProperties;\n    let props = Object.create(ownerProperties || null);\n    let hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n    let propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n    let propertiesMatchingHost = propertyData.properties\n    Object.assign(\n      props,\n      hostAndRootProps.hostProps,\n      propertiesMatchingHost,\n      hostAndRootProps.rootProps\n    );\n    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n    StyleProperties.reify(props);\n    styleInfo.styleProperties = props;\n  }\n  _mixinOverrideStyles(props, overrides) {\n    for (let p in overrides) {\n      let v = overrides[p];\n      // skip override props if they are not truthy or 0\n      // in order to fall back to inherited values\n      if (v || v === 0) {\n        props[p] = v;\n      }\n    }\n  }\n  _updateNativeProperties(element, properties) {\n    // remove previous properties\n    for (let p in properties) {\n      // NOTE: for bc with shim, don't apply null values.\n      if (p === null) {\n        element.style.removeProperty(p);\n      } else {\n        element.style.setProperty(p, properties[p]);\n      }\n    }\n  }\n  /**\n   * Update styles of the whole document\n   *\n   * @param {Object=} properties\n   */\n  updateStyles(properties) {\n    this.applyStyle(this._documentOwner, properties);\n  }\n  /* Custom Style operations */\n  _revalidateCustomStyleApplyShim(customStyles) {\n    for (let i = 0; i < customStyles.length; i++) {\n      let c = customStyles[i];\n      if (c['_style']) {\n        this._revalidateApplyShim(c['_style']);\n      }\n    }\n  }\n  _applyCustomStyles(customStyles) {\n    for (let i = 0; i < customStyles.length; i++) {\n      let c = customStyles[i];\n      if (c['_style']) {\n        this._applyCustomStyleToDocument(c['_style']);\n      }\n    }\n    window['CustomStyle']['_documentDirty'] = false;\n  }\n  _transformCustomStyleForDocument(style) {\n    let ast = StyleUtil.rulesForStyle(style);\n    StyleUtil.forEachRule(ast, (rule) => {\n      if (nativeShadow) {\n        StyleTransformer.normalizeRootSelector(rule);\n      } else {\n        StyleTransformer.documentRule(rule);\n      }\n      if (nativeCssVariables) {\n        ApplyShim.transformRule(rule);\n      }\n    });\n    if (nativeCssVariables) {\n      style.textContent = StyleUtil.toCssText(ast);\n    } else {\n      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n    }\n  }\n  _revalidateApplyShim(style) {\n    if (nativeCssVariables) {\n      let ast = StyleUtil.rulesForStyle(style);\n      ApplyShim.transformRules(ast);\n      style.textContent = StyleUtil.toCssText(ast);\n    }\n  }\n  _applyCustomStyleToDocument(style) {\n    if (!nativeCssVariables) {\n      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n    }\n  }\n  getComputedStyleValue(element, property) {\n    let value;\n    if (!nativeCssVariables) {\n      // element is either a style host, or an ancestor of a style host\n      let styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n      value = styleInfo.styleProperties[property];\n    }\n    // fall back to the property value from the computed styling\n    value = value || window.getComputedStyle(element).getPropertyValue(property);\n    // trim whitespace that can come after the `:` in css\n    // example: padding: 2px -> \" 2px\"\n    return value.trim();\n  }\n  // given an element and a classString, replaces\n  // the element's class with the provided classString and adds\n  // any necessary ShadyCSS static and property based scoping selectors\n  setElementClass(element, classString) {\n    let root = element.getRootNode();\n    let classes = classString ? classString.split(/\\s/) : [];\n    let scopeName = root.host && root.host.localName;\n    // If no scope, try to discover scope name from existing class.\n    // This can occur if, for example, a template stamped element that\n    // has been scoped is manipulated when not in a root.\n    if (!scopeName) {\n      var classAttr = element.getAttribute('class');\n      if (classAttr) {\n        let k$ = classAttr.split(/\\s/);\n        for (let i=0; i < k$.length; i++) {\n          if (k$[i] === StyleTransformer.SCOPE_NAME) {\n            scopeName = k$[i+1];\n            break;\n          }\n        }\n      }\n    }\n    if (scopeName) {\n      classes.push(StyleTransformer.SCOPE_NAME, scopeName);\n    }\n    if (!nativeCssVariables) {\n      let styleInfo = StyleInfo.get(element);\n      if (styleInfo && styleInfo.scopeSelector) {\n        classes.push(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n      }\n    }\n    StyleUtil.setElementClassRaw(element, classes.join(' '));\n  }\n  _styleInfoForNode(node) {\n    return StyleInfo.get(node);\n  }\n}\n\nShadyCSS.prototype['flush'] = ShadyCSS.prototype.flush;\nShadyCSS.prototype['prepareTemplate'] = ShadyCSS.prototype.prepareTemplate;\nShadyCSS.prototype['applyStyle'] = ShadyCSS.prototype.applyStyle;\nShadyCSS.prototype['updateStyles'] = ShadyCSS.prototype.updateStyles;\nShadyCSS.prototype['getComputedStyleValue'] = ShadyCSS.prototype.getComputedStyleValue;\nShadyCSS.prototype['setElementClass'] = ShadyCSS.prototype.setElementClass;\nShadyCSS.prototype['_styleInfoForNode'] = ShadyCSS.prototype._styleInfoForNode;\nShadyCSS.prototype['_transformCustomStyleForDocument'] = ShadyCSS.prototype._transformCustomStyleForDocument;\nShadyCSS.prototype['getStyleAst'] = ShadyCSS.prototype.getStyleAst;\nShadyCSS.prototype['styleAstToString'] = ShadyCSS.prototype.styleAstToString;\nObject.defineProperties(ShadyCSS.prototype, {\n  'nativeShadow': {\n    get() {\n      return nativeShadow;\n    }\n  },\n  'nativeCss': {\n    get() {\n      return nativeCssVariables;\n    }\n  }\n});\n\nwindow['ShadyCSS'] = new ShadyCSS();","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n'use strict';\n\nexport default class StyleCache {\n  constructor(typeMax = 100) {\n    // map element name -> [{properties, styleElement, scopeSelector}]\n    this.cache = {};\n    this.typeMax = typeMax;\n  }\n\n  _validate(cacheEntry, properties, ownPropertyNames) {\n    for (let idx = 0; idx < ownPropertyNames.length; idx++) {\n      let pn = ownPropertyNames[idx];\n      if (cacheEntry.properties[pn] !== properties[pn]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  store(tagname, properties, styleElement, scopeSelector) {\n    let list = this.cache[tagname] || [];\n    list.push({properties, styleElement, scopeSelector});\n    if (list.length > this.typeMax) {\n      list.shift();\n    }\n    this.cache[tagname] = list;\n  }\n\n  fetch(tagname, properties, ownPropertyNames) {\n    let list = this.cache[tagname];\n    if (!list) {\n      return;\n    }\n    // reverse list for most-recent lookups\n    for (let idx = list.length - 1; idx >= 0; idx--) {\n      let entry = list[idx];\n      if (this._validate(entry, properties, ownPropertyNames)) {\n        return entry;\n      }\n    }\n  }\n}\n"]}